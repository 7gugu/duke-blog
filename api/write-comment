#!/usr/bin/env python3
#
# Software License Agreement (MIT License)
# Author: Duke Fong <d@d-l.io>

import cgi, sys, os, json, filelock
from datetime import datetime
from Crypto.Cipher import AES
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
from conf.gconf import gconf

print('Content-Type: application/json; charset=utf-8\n')

#data = sys.stdin.read()
data = sys.stdin.read(int(os.environ.get('CONTENT_LENGTH', 0)))

if data:
    class Form(dict):
        pass
    form = Form(json.loads(data))
    form.getvalue = form.get
else:
    form = cgi.FieldStorage()

url = form.getvalue('url')
#user = form.getvalue('user')
#password = form.getvalue('password')

def mask_email(email):
    name, domain = email.split('@')
    d1, d2 = domain.rsplit('.', 1)
    return name[:int(len(name)/2)] + '~@' + d1[:int(len(d1)/2)] + '~.' + d2

def to_hexstr(data):
    return ''.join('%02x' % b for b in data)

def get_cipher():
    return AES.new(bytes.fromhex(gconf['cipher']['key']), AES.MODE_CBC, bytes.fromhex(gconf['cipher']['iv']))

def _pad(d):
    d = bytes(d, encoding="utf-8")
    bs = 16
    p_cnt = bs - len(d) % bs
    return d + bytes([p_cnt]) * p_cnt

def _unpad(d):
    return d[:-d[-1]].decode(encoding="utf-8")

comment = {}
url = form.getvalue('url')
comment['date'] = datetime.now().astimezone().isoformat(sep='T', timespec='seconds')
comment['email'] = to_hexstr(get_cipher().encrypt(_pad(form.getvalue('email').lower())))
comment['masked'] = mask_email(form.getvalue('email').lower())
comment['registered'] = False
comment['name'] = form.getvalue('name')
comment['site'] = form.getvalue('site')
comment['format'] = 'md'
body = form.getvalue('body')

if not url or not comment['email'] or not comment['name'] or not body:
    print('{"error": "Must input email, name and body!"}')
    exit(-1)

article_dir = '../articles/' + url
comments_dir = article_dir + '/_comments'
lock = filelock.FileLock(article_dir + '/.lock', timeout=5)
if not os.path.exists(comments_dir):
    os.makedirs(comments_dir)

def cal_comment_id():
    # TODO: support sub comment dir, e.g '2.1'
    ids = [int(x.split('_')[0]) for x in os.listdir(comments_dir)]
    return max(ids)+1 if len(ids) else 1

try:
    with lock:
        bbb = cal_comment_id()
        if gconf['reply']['need-review']:
            comment_dir = comments_dir + '/%d_tmp' % cal_comment_id()
        else:
            comment_dir = comments_dir + '/%d' % cal_comment_id()
        os.makedirs(comment_dir)
except filelock.Timeout:
    print('{"error": "filelock.Timeout"}')
    print(f'create comment failed: filelock.Timeout {url}', file=sys.stderr)
    exit(-1)

with open(comment_dir + '/body.%s' % comment['format'], 'w') as file:
    file.write(body)
with open(comment_dir + '/_metadata', 'w') as file:
    file.write(json.dumps(comment, indent=2, ensure_ascii=False, sort_keys=False))

if gconf['reply']['need-review']:
    print('{"success": "Post successed, waiting for review."}')
else:
    print('{"success": "Post successed, refreshing...", "refresh": true}')

